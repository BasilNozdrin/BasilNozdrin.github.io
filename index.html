<!DOCTYPE html>
<html>
	<head>
		<title>Commutator Length in Free Group</title>
		<meta charset="utf-8">
	</head>
	<body style="background-color: #FFFFFF";>
		<p><h1>Commutator Length in Free Group</h1></p>
		<hr><hr>
		<p><h2 align="left">Opposite word</h2>
			<span>Enter word:</span><input id="opWordInput_id" type="text">
			<button id="opWordButton_id" type="button" onclick="opWordFunction()">Enter</button>
			<span>Result:</span><span id="opWordOutput_id"; style="font-weight: bold;"></span>
		</p>
		<hr>
		<p><h2 align="left">Word Check</h2>
			<span>Enter word:</span><input id="wordCheckInput_id" type="text">
			<button id="wordCheckButton_id" type="button" onclick="wordCheckFunction()">Enter</button>
			<span>Result:</span><span id="wordCheckOutput_id"; style="font-weight: bold;"></span>
		</p>
		<hr>
		<p><h2 align="left">Fialkovsky decomposition</h2>
			<span>Enter word:</span><input id="fialkDecomposeIn_id" type="text">
			<button id="fialkDecomposeButton_id" type="button" onclick="fialkDecompose()">Enter</button>
			<p><h3 align="left">Result:</h3>
			<span id="fialkDecomposeOut_id"; style="font-weight: bold;"></span>
			</p>
		</p>
		<hr>
		<p><h2 align="left">ALERT! DOES NOT WORK WITH EMPTY WORD OR ERASED CELL! Word sum</h2>
			<input type="text" id="word1"/>
			<input type="text" id="word2"/>
			<span id="result"; style="font-weight: bold;"></span>
		</p>
		<script type="text/javascript">
			function opWordFunction() {
				let opWordIn = document.getElementById("opWordInput_id");
				let opWordOut = document.getElementById("opWordOutput_id");
				let text = opWordIn.value;
				let new_text = "";
				for (let char_idx = text.length - 1; char_idx >= 0; char_idx--) {
					let char = text.charAt(char_idx);
					if (char.toUpperCase() === char.toLowerCase()) {
						new_text = "Error";
						break;
					}
					if (char === char.toUpperCase()) {
						new_text += char.toLowerCase();
					} else {
						new_text += char.toUpperCase();
					}
				}
				opWordOut.innerHTML = new_text;
			}
			function wordCheckFunction() {
				let wordCheckIn = document.getElementById("wordCheckInput_id");
				let wordCheckOut = document.getElementById("wordCheckOutput_id");
				function innerfunc() {
				let wdChInCopy = Array.from(wordCheckIn.value);
				let countLcl = 0;
				let countUcl = 0;
				while (wdChInCopy.length !== 0) {
					lower_case_l = wdChInCopy[0].toLowerCase();
					upper_case_l = wdChInCopy[0].toUpperCase();
					arr1 = wdChInCopy.filter(x => (x == lower_case_l)||(x == upper_case_l));
					countLcl = 0;
					countUcl = 0;
					for (let i = arr1.length; i >= 0; i--) {
						if (arr1[i-1] == lower_case_l) {countLcl += 1;}
						if (arr1[i-1] == upper_case_l) {countUcl += 1;}
					}
					if (countLcl != countUcl) {return false;}
					wdChInCopy1 = wdChInCopy.filter(x => (x != lower_case_l)&&(x != upper_case_l));
					wdChInCopy = wdChInCopy1;
				}
				return true;
				}
				if (innerfunc()==true){
				wordCheckOut.innerHTML = "In commutator";
				} else {
				wordCheckOut.innerHTML = "Not in commutator";
				}
			}
			//function fialkDecompose() {
			//	let fialkDecomposeIn = document.getElementById("fialkDecomposeIn_id");
			//	let fialkDecomposeOut = document.getElementById("fialkDecomposeOut_id");
			//	let old_value = Array.from(fialkDecomposeIn.value);
			//	let new_value = "";
			//	for (перебор вариков) {
			//	перебор вариков (for(for)) -> newbie
			//	new_value = new_value + "\n" + newbie.join()
			//	}
			//	fialkDecomposeOut.innerHTML = new_value;
			//}
			function not_mine(){
				let word1 = document.querySelector("#word1");
				let word2 = document.querySelector("#word2");
				let result = document.querySelector("#result");
				function invert_word(word) {
					let new_word = "";
					for (let char_idx = word.length - 1; char_idx >= 0; char_idx--) {
						let char = word.charAt(char_idx);
						if (char === char.toUpperCase()) {
							new_word += char.toLowerCase();
						} else {
							new_word += char.toUpperCase();
						}
					}
					return new_word;
				}
				function do_ur_work() {
					let first = invert_word(word1.value);
					let second = word2.value;
					let shorter_len = 0;
					if (first.length < second.length) {
						shorter_len = first.length;
					} else {
						shorter_len = second.length;
					}
					while (true) {
						if (first[0] === second[0]) {
							first = first.slice(1);
							second = second.slice(1);
						} else {
						break;
						}
					}
					result.innerHTML = invert_word(first) + second;
				}
				word1.addEventListener('input', do_ur_work);
				word2.addEventListener('input', do_ur_work);
				}
			not_mine();
		</script>
	</body>
</html>